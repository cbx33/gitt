% chap5.tex - Week 5
\cleardoublepage
%\phantomsection
\chapter{Week 5}

\section{Day 1 - ``This isn't working for me John''}
\subsection{Dealing with resistance}

So, now that the team have discovered the basics of branching, they are conceptually ready to start using it in earnest.  When implementing a version control system, or shifting from one to another, it is important to make sure that the users are happy with the system and know how to use it.  Training is a big issue.

It would seem that the team have coped with the initial usage of Git and that they have utilised each others talents in specific areas to pull together a good learning environment.  However, one thing to bare in mind is that some users may secretly be having a far worse experience than their colleagues.  It is also common for these people to suffer in silence, or to wait until they are asked for their opinions on the system before they bring up any issues.

It is because of these very factors that you should probably consider employing a parallel implementation.  This is exactly what John decided to do with Tamagoyaki Inc's implementation of Git.  Whilst a parallel implementation does take duplicate effort in some areas, it also allows the team to return to their original system, should insurmoutable obstacles present themselves.  However, a parallel implementation should never be an excuse not to eventually shift over to the new system, unless serious issues are discovered.

\begin{figure}[hbt]
\tikzstyle{mybox} = [draw=black, fill=gray!20, very thick, rectangle, rounded corners, inner sep=15pt, inner ysep=20pt]
\tikzstyle{fancytitle} =[fill=black, text=white]
\begin{tikzpicture}
\node [mybox] (box){%
    \begin{minipage}{.9\textwidth}
Parallel implementation means keeping your old system running, whilst bringing up a new one.  It incurs extra effort in many areas, such as system administration, backups and system usage, but it allows people to evaluate a product in a real life situation.  Usually people people will have completed all of their preliminary testing before moving onto Parallel implementation.  It would be assumed that you were fairly certain that your were going to move forward with a final implementation, before taking the time of setting up and training people on the new system.
\newline
\newline
It does however allow people to continue with the day jobs, without the risk of issues with the new system completely blocking them from working.  This is often a critical factor when implementing a new system.  If the system is successful, over time, the users will migrate away from the old system and start using the new system exclusively.  Care should also be taken that whilst in the midst of parallel implementation, both systems remain up to date at all times, this is often the trickiest part.  In Tamagoyaki Inc's case, because they were just using tarballs of their code base, it is easy for them to tar up a folder, as well as commit it to the repository.
    \end{minipage}
};
\node[fancytitle, right=16pt] at (box.north west) {Parallel Implementation};
\node[fancytitle, rounded corners] at (box.west) {\rotatebox{90}{Terminology}};
\end{tikzpicture}
\end{figure}

\begin{trenches}
``I'm sorry John, but I just can't do this anymore!''  Eugene was leaning over the partition wall, the keys that hung around his neck clattering loudly as he swayed.  ``You hard core devs may be happy with all that command line junk, but I'm a GUI kinda guy.  It doesn't come as easily for me as if does for you.''

``You should learn how to use a computer properly then,'' shouted Klaus before laughing.

Eugene was livid, ``You're such a damn elitist Klaus.  I'm so glad I don't have to share a pod with you anymore, you zealot.''  With that, Eugene was off, flinging open the door to the office area and stomping off to his desk.

``Nice one Klaus,'' said John, ``You know, you could be a little more tactful.  We do still need sign off from him to complete this project.''

Klaus shrugged.

\begin{center} * * * \end{center}

``Listen Eugene, I think I have a way to help you out.  There is a GUI component to Git that you can use.''  John was trying his best, but five minutes of grovelling to Eugene, hadn't exactly paid off.

``I'll try your GUI, but if I don't like it, I'm not signing off.''  He was serious too.  ``I don't have time to waste learning this system, I never needed versioning before, why should I need it now.''

``We have to work together on things now Eugene,'' began John, ``You know there is a merger looming, right?''  

Eugene looked up, a little stunned.

``We have to show we can function well as a team, that we have everything in hand.  Let's leave the integration till the end of the week, to give you a little more time to get used to things.''

``OK'' said Eugene, ``I'll give it my best shot''
\end{trenches}

Sometimes, dealing with resistance to new systems is hard.  In Tamagoyaki Inc, John was blessed with the fact that only one developer didn't like the system he had picked.  Fortunately, the developer in question was only really concerned with the lack of a GUI, something that Git actually provides anyway.

It is very important to listen to users issues and questions.  Often they may discover a big hole in your initial planning which you would never have seen.  Never dismiss a concern before looking into it as it can be difficult for one person to understand the entire process in place during development, no matter how well documented it is.  Going through a period of User Acceptance Testing is crucial before complete adoption is even considered.

Let us take a while to explore the build in GUI that Git comes bundled with.

\subsection{A little bit of graphics}
Whilst using a GUI can be faster for some operations, it is also worth noting that with very few exceptions, GUI's are often less feature rich than their CLI counterparts.  It is very time consuming to write a GUI that can deal with every command option a user desires, so often the GUI will handle the most common use cases, leaving the CLI to handle special cases.

Git is no exception to this rule.  Whilst the gui component is a very capable tool indeed, it does lack most of the advanced functionality that can be found on the command line.  In fact, there are even some of the basic parameters to some of the commands that we have used earlier, that are not available in the GUI counterpart.

We can invoke the GUI by running the \texttt{git gui} command.  We will be presented with a window similar to that in Figure 1.  Note that in this case, we are running it against our test repository that we have been working on through previous chapters.

\begin{figure}[hbt]
\centering
\includegraphics[width=11cm]{images/f-w5-d1.png}
\caption{Initial Git GUI view}
\end{figure}

This initial window is composed of four key areas
\begin{enumerate}
\item \textbf{Unstaged} - This area on the screen shows all of the items present in the working copy which are unstaged, that is to say they have not yet been added to the index and so will not be included if a commit were to take place.
\item \textbf{Staged} - This area on the screen shows all of the items present in the index or staging area.  Everything listed here will be included if a commit takes place.
\item \textbf{Content View} - This region of the window will show the contents of an item if it is selected in either the Unstaged or Staged areas.  If the file is already tracked, then the window will show a diff between the last committed version and the chosen version.
\item \textbf{Commit} - From the commit section of the screen, the commit message can be written, the commit performed, the directory rescanned for changes, as well as other operations.
\end{enumerate}

If we take a closer look at the \textbf{Unstaged} area of the screen, we see something interesting.  This is shown in Figure 2.

\begin{figure}[hbt]
\centering
\includegraphics[width=5cm]{images/f-w5-d2.png}
\caption{Unstaged section}
\end{figure}

This is the only file in our working copy which contains unstaged changes.  That should not be surprising as this file has never been added to the repository so it is not considered \textbf{tracked} by Git.  If you remember, it was actually a temporary file that we piped some output to in an earlier chapter.  If we click on the filename of this file, the \textbf{Content View} area changes to show Figure 3.

\begin{figure}[hbt]
\centering
\includegraphics[width=11cm]{images/f-w5-d3.png}
\caption{Content view of \texttt{temp\_file}}
\end{figure}

In the top banner section of the \textbf{Content View} we see an indication of the file's status.  In this case it is \textbf{Untracked} and \textbf{not staged}.  We can change this by clicking on the small blank page icon to the left of the file name in the \textbf{Unstaged} area of the screen, see Figure 4.

\begin{figure}[hbt]
\centering
\includegraphics[width=5cm]{images/f-w5-d4.png}
\caption{Staged section}
\end{figure}

Now the file has moved into the \textbf{Staged} area of the screen as would be equivilent to us doing a \texttt{git add temp\_file}.  The file has been added to the index and is now ready for committing.  We also notice a difference in the \textbf{Content View} of \texttt{temp\_file}.  This can be seen in Figure 5.

\begin{figure}[hbt]
\centering
\includegraphics[width=11cm]{images/f-w5-d5.png}
\caption{Content view of \texttt{temp\_file}}
\end{figure}

Now the bar reads that the file is \textbf{Staged for commit}, which is exactly what we expect.  We are now going to fill out a commit message, which can be seen in Figure 6, and press the \textbf{Commit} button, to initialise a commit into the repository.

\begin{figure}[hbt]
\centering
\includegraphics[width=11cm]{images/f-w5-d6.png}
\caption{Preparing for commit}
\end{figure}

It should be noted here that we could have performed multiple operations here, adding several files to the the staging area before pressing that all important \textbf{Commit} button.  We will finish this section off by checking the status area at the very bottom of the screen.  In Figure 7, you should see that our latest operation has been summarised by the string \texttt{Created commit 35243bf8: Added temp\_file}

\begin{figure}[hbt]
\centering
\includegraphics[width=11cm]{images/f-w5-d7.png}
\caption{Status message showing new commit ID}
\end{figure}

\section{Day 2 - ``Back to logging''}
\subsection{Visualisation to the max}

With the basic operations down, as we discovered in Week 1, let us now move on to using the GUI to view the history of our database.  The visualiser that is bundled with Git is packed with features and can be invoked in one of two ways, either by running \texttt{gitk} from the command line, or by choosing \textbf{\emph{Repository - Visualize All Branch History}} or \textbf{\emph{Repository - Visualize master's Branch History}}, the latter menu item is worded with the assumption that you are on the \textbf{master} branch of course.

Whichever way we begin an instance of \texttt{gitk}, we are likely to end up with a screen like the one in Figure 8.

\begin{figure}[hbt]
\centering
\includegraphics[width=11cm]{images/f-w5-d8.png}
\caption{Initial \texttt{gitk} view}
\end{figure} 

Let us spend a few minutes familiarising ourselves with the layout of the \texttt{gitk} tool.  The window is split up into roughly seven different areas.  We will take a brief look at each of these below.

\begin{enumerate}
\item \textbf{History Graph} - This area of the screen gives a graphical representation of the history of our repository.  Similar to the \texttt{git log --graph} option that we used previously, the graph here is much more readable.
\item \textbf{Committer History} - The committer history tells us the person who added the commit which is horizontally adjacent in the commit graph.  
\item \textbf{Date History} - The date history is very similar to the committer history section of the screen and shows us a simple view of the date of the commit which is horizontally adjacent.
\item \textbf{History Search} - This section of the screen allows you to narrow down and highlight a subset of commits which meet a certain criteria.  It also allows you to navigate through these results.
\item \textbf{Commit Search} - Once you have highlighted a commit, the commit search section allows you to find specific strings within that commit, including looking at just old or new lines to the repository.
\item \textbf{Content View} - This window actually shows the data that was stored in the commit and allows you scroll through either changes or complete files.
\item \textbf{File System View} - The file system view shows you a list of files that were either modified in a specified commit, or that were present in the commit.
\end{enumerate}

To start with, let us take a look at the graph that is present in \textbf{History Graph} section of the screen in Figure 9.  Essentially this is just a very simplifed version of the graphs we were drawing in the previous chapter.  As you can see, the only information that appears to be missing from the graph is the commit ID, which can be obtained quite easily by clicking on the relevant commit and viewing the string presented just below the graph pane.

\begin{figure}[hbt]
\centering
\includegraphics[width=10cm]{images/f-w5-d9.png}
\caption{Graphical history of repository}
\end{figure} 

The historical graph shows us all active branches, tags and commits.  From looking at this it is easy to see where our merges occured and where the branch HEADs point to.  The branches are identified by green rectangles, and the tags as yellow labels.  Each circle on the graph is a commit and is linked to the panes on the right, where you can see the committer and date information.

If we select the \textbf{master} branch HEAD, which should be the top commit, (in fact on opening \texttt{gitk} this should already be selected), we should see a pane similar to Figure 10 in the \textbf{Content View} section of the screen.

\begin{figure}[hbt]
\centering
\includegraphics[width=10cm]{images/f-w5-d10.png}
\caption{Content view of master HEAD}
\end{figure} 

Notice in this that we have two parents listed, which is what we would expect, as the last commit we did was that of a merge from \textbf{zaney} into \textbf{master}.  Notice also that below this, we get to see a diff output of exactly what changed during this merge.  Interestingly, it shows that \texttt{newfile1} loses one line from parent \textbf{ed2301b} and another from parent \textbf{7cc32db}.  These are both replaced by the next line, which reads \texttt{and some more awesome changes}.

The current commit is a little special as it is a merge.  If you choose any normal commit, you can use the \texttt{Diff}, \texttt{Old version} and \texttt{New version} buttons to either show what the file used to look like (Old), what it looks like now (New), or the default view which is the Diff and shows the combination of the changes.

Above the \textbf{File System View} pan is a button to switch between \texttt{Patch} and \texttt{Tree} views.  By default, this is set to \texttt{Patch} and changes what the \textbf{Content View} pane displays.  When set to \texttt{Patch}, this shows us the changes between the old commit and the new one.  However, when we switch this to \texttt{Tree} view the \textbf{Content View} pane changes to show the contents of a file selected from its pane, at the current commit.  In this way, it allows you to browse and display files from previous commits graphically and effortlessly.  Simply select the commit, selected \texttt{Tree} mode, choose the file, et voila, it is presented in the \textbf{Content View} pane.

So as you can see, the \texttt{gitk} tool is already quite powerful.  We are now going to take things a step further.  Remember in \textbf{Week 3} we had a way of searching the repository for the introduction of a string.  We can do the exact same thing with \texttt{gitk}.  

We are going to drop down the box which currently reads \texttt{contains:} in the \textbf{History Search} pane and change it to \texttt{add/removing string:}.  Then we are going to enter \texttt{Change1} into the field on the right.  Your changes should look similar to Figure 11.

\begin{figure}[hbt]
\centering
\includegraphics[width=10cm]{images/f-w5-d11.png}
\caption{Searching for a string}
\end{figure} 

After you have finished typing you should already have noticed a difference in the \textbf{History Graph} pane.  Notice how some commits are now highlighted in bold, as demonstrated in Figure 12?

\begin{figure}[hbt]
\centering
\includegraphics[width=10cm]{images/f-w5-d12.png}
\caption{Search results}
\end{figure} 

If you remember from Week 3, when we first ran the \texttt{git log -SChange1} command, we were presented with only one commit.  That was titled, \texttt{Made a few changes to first and second files}.  Our repository has moved on since then and we can see that that particular string, \texttt{Change1} was added or removed in two other commits as well.  This was when we totally changed \texttt{my\_second\_committed\_file} and when we removed \texttt{my\_first\_committed\_file} a little later.  The \textbf{Next} and \textbf{Previous} buttons can be used to navigate through the search results.

Now that we have found the commits that contain the change to the string we are looking for.  The question is, where in the file does this change occur?  We can now use the \textbf{Commit Search} pane to see this.  Typing \texttt{Change1} into this search box will highlight the relevant text in the \texttt{Content View} pane below.  It really is as easy as that.

Whilst it is a great idea to remember and use the command line arguments and parameters, it is also useful to know that these other tools are available.  GUI tools should not be frowned upon, as some command line purists do.  GUI tools are as much a part of the development process as their command line counterparts.  Both have their uses and the most important lesson of all is to know when to use which.  This lesson will most likely come with experience and time, or as a friend of mine used to put it, old age.

\section{Day 3 - ``Advanced Views''}
\subsection{Customising the visualisation}

\begin{trenches}
``Eugene,'' called Klaus as the tools developer walked past him.  ``Could I borrow you for a second?''

``I guess,'' said Eugene coldly.  ``What is it that you want exactly?''

``Well,'' Klaus began, ``I started using the GUI tools a little and found something you might consider interesting.  I know you spend a lot of time switching between different versions of our code looking for various functions and things and I found this cool tool in the GUI.''

Eugene breathed in deeply.  Knowing Eugene, it wouldn't be anything amazing, but nevertheless, his interest had been piqued.
\end{trenches}

\begin{figure}[hbt]
\centering
\includegraphics[width=10cm]{images/f-w5-d13.png}
\caption{Search results}
\end{figure} 

\begin{figure}[hbt]
\centering
\includegraphics[width=10cm]{images/f-w5-d14.png}
\caption{Search results}
\end{figure} 


\clearpage

\section{Summary - John's Notes}
\subsection{Commands}
\begin{itemize}

\item\texttt{git gui} - Invokes the Git gui tool

\end{itemize}

\subsection{Terminology}
\begin{itemize}
\item\textbf{Stash} - A temporary storage of local modifications that can be brough back onto the branch at a later date
\end{itemize}

%wmctrl -r Gui -e 0,0,0,811,500
